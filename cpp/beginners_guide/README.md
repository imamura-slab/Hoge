# beginner's guide to C++
- 参考サイト
  - [C++入門](http://wisdom.sakura.ne.jp/programming/cpp/)

***
## ヘッダ
```
#include <iostream>
using namespace std;
```

***
## 標準入出力
- 標準出力には`std::cout`, 標準入力には`std::cin`を使用する.  
  ヘッダに`using namespace std`と記述することで, `cout`や`cin`だけでよくなる.
  
### 標準出力
```
cout << "hoge \n";
cout << 2020 << "/" << 8 << "/" << 12 << "\n" ;

>>> hoge
>>> 2020/8/12
```

### 標準入力
- `value`には, 入力された値を格納する`変数`を指定する. (`アドレス`ではない)
```
cin >> value;
```



***
## [クラス](https://github.com/imamura-slab/Hoge/tree/master/cpp/class)
### 基本形
```
class [tag [: base-list]]{
member-list
} [declarators];
```

tag : クラス型の名前を指定

base-list : ベースクラスの名前を指定

member-list : クラスのメンバ, またはフレンドを宣言

declarators : オブジェクトを1つ以上宣言


### コンストラクタ
- オブジェクト生成時に自動で呼び出される関数
  - オブジェクトが初期値として持つべき値などをここで設定する
- コンストラクタ関数はクラスと同じ名前の関数. 戻り値は存在しない

```
class class-name{
    class-name(){                    // コンストラクタ {
        初期化処理などをココで行う   //
    }                                // コンストラクタ }
}
```

### デストラクタ
- オブジェクトの消滅時に自動で呼び出される関数
  - オブジェクトが破壊されるタイミングはスコープから外れたとき
- コンストラクタの名前の前にチルダ(`~`)をつけることでデストラクタ関数になる. 戻り値なし. 仮引数も渡せない.
```
class class-name{
    ~class-name(){                   // デストラクタ {
        .....                        //
    }                                // デストラクタ }
}
```



***
## [スコープ](https://github.com/imamura-slab/Hoge/tree/master/cpp/scope)
- クラスのメンバ関数内のローカル変数名とメンバ変数名が同じであるとき, ローカル変数の方が優先される.
  メンバ変数を明示したいときはスコープ解決演算子`::`を使用して, `クラス名::メンバ変数名`とする
- さらに, グローバル変数を明示したいときは`::グローバル変数名`とする
- もちろん関数も同様に...



***
## オブジェクト
- 同じクラスのオブジェクトであればオブジェクトレベルでの代入を行うことができる
```
class-name obj1, obj2;
obj2 = obj1;
```
- オブジェクトの代入はすべてのメンバがコピーされる
- 一方のメンバのデータを変更しても, もう一方のオブジェクトに影響はない
- ただ, もしメンバ変数がポインタで, あるメモリアドレスを指していた場合, 二つの異なるオブジェクトが全く同じメモリアクセス指すことになる.  
  -> オブジェクトの代入はあまり良くない.



***
## 値渡し, ポインタ渡し, 参照渡し
- .....



***
## インライン関数
- インライン展開 : 関数呼び出し部分がインライン関数の内容に置換されること
```
inline type function();
```
- inlineを指定すれば必ずインライン関数になるわけではなく, コンパイラの制限に従う必要がある

#### メリット
- 関数呼び出しの負荷がなくなり, 高速化が見込める
#### デメリット
- ファイルサイズの増大





***
## [thisポインタ](./this)
- メンバ関数内からしかアクセスできない, オブジェクトを表すポインタ
- このポインタはメンバ関数の対象オブジェクトへのポインタを格納している
- クラスのメンバを参照するするときもthisポインタを使うことができるが, 実際は不要



***
## [オーバーロード](./overload)
- 引数の数あるいはデータ型が異なる同名の関数を多重定義すること
- 関数名が同じでも, シグネチャ(Java言語において関数名と引数を含めたもののこと)が異なる場合はオーバーロードできる



***
## [コピーコンストラクタ](./copy_constructor)
- 関数にオブジェクトを渡したり, あるいは戻り値として受け取った場合, オブジェクトはそっくりそのままコピーされる. そのオブジェクトが動的に割り当てたメモリ領域へのポインタ型メンバ変数を保有していた場合, このポインタのアドレスも同じものを指すので, データの整合性が保てなくなる.
- この問題を回避するにはコピー用の初期化をする必要があり, オブジェクトのコピーがとられたときに実行する処理をコピーコンストラクタという
- コピーコンストラクタはオブジェクトの初期化時に呼び出されるもので, 宣言時, 引数, 戻り値の3つの動作でコピーがとられたときに実行される
- 関数名はコンストラクタと同様にクラス名と同じで, const指定のコピー元のオブジェクトの参照を受け取るようにする
```
class-name(const class-type &obj)
```


